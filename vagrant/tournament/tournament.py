#!/usr/bin/env python
# 
# tournament.py -- implementation of a Swiss-system tournament
#
import psycopg2


# Connecting to PSQL tournament database
def connect():
    """Connect to the PostgreSQL database.  Returns a database connection."""
    return psycopg2.connect("dbname=tournament")


# Table deletion functions in PSQL
def deletePlayers():
    """Remove all the player records in players and scoreboard table for all tournament from the database and reset players id sequence to start from 1"""
    conn = connect()
    c = conn.cursor()
    c.execute("DELETE FROM players;")
    c.execute("ALTER SEQUENCE players_pid_seq RESTART WITH 1;")
    c.execute("DELETE FROM scoreboard;")
    conn.commit()
    conn.close()


def deleteMatches():
    """Remove all the match records from the database and reset match id sequence to start from 1"""
    conn = connect()
    c = conn.cursor()
    c.execute("DELETE FROM matches;")
    c.execute("ALTER SEQUENCE matches_mid_seq RESTART WITH 1;")
    conn.commit()
    conn.close()


def deleteTournaments():
    """Remove all the tournament records from the database but keeping sequence rolling to avoid duplication

    """
    conn = connect()
    c = conn.cursor()
    c.execute("DELETE FROM tournaments;")
    c.execute("ALTER SEQUENCE tournaments_tid_seq RESTART WITH 1;")
    conn.commit()
    conn.close()


# Registering tournament & players
def registerTournament(name):
    """Adds a tournament to database.

    The database assigns a unique serial id number for each tournament. (This
    should be handled by your SQL database schema, not in your Python code.)

    Args:
      name: the tournament name (need not be unique).

    Returns:
      t_id: the id of tournament generated by the system.
    """
    conn = connect()
    c = conn.cursor()
    c.execute("INSERT INTO tournaments (tname) VALUES (%s) RETURNING tid;", (name,))
    t_id = c.fetchone()[0]
    conn.commit()
    conn.close()
    return t_id


def registerPlayer(name, **kwargs):
    """Adds a player to the tournament database.

    The database assigns a unique serial id number for the player.  (This
    should be handled by your SQL database schema, not in your Python code.)

    Args:
      name: the player's full name (need not be unique).
      tid:  the tournament player is registered (optional). Default as 1.
    """
    if 'tid' in kwargs:
        tid = kwargs['tid']
    else:
        tid = 1
    conn = connect()
    c = conn.cursor()
    c.execute("INSERT INTO players (pname) VALUES (%s) RETURNING pid;", (name,))
    p_id = c.fetchone()[0]
    c.execute("INSERT INTO scoreboard VALUES(%s,%s,%s,%s,%s,%s,%s,%s);", (p_id, tid, 0, 0, 0, 0, 0, 0,))
    conn.commit()
    conn.close()


# Counting Players for code testing
def countPlayers(**kwargs):
    """Returns the number of players currently registered in a specific tournament.

    Args:
        tid: tournament id from tournament table (Optional) (Default as 1)
    """
    conn = connect()
    c = conn.cursor()

    if 'tid' in kwargs:
        tid = kwargs['tid']
    else:
        tid = 1
    c.execute("SELECT count(spid) FROM scoreboard WHERE stid=%s;", (tid,))
    p_count = c.fetchone()[0]
    return p_count


# Assigning player standings and pairing for scorecard
def playerStandings(**kwargs):
    """Returns a list of the players and their win records, sorted by wins.

    The first entry in the list should be the player in first place, or a player
    tied for first place if there is currently a tie.

    Standing is arranged in the following order:
    1) Total score based on win/lose/draw/bye
    2) Opponent Match Win for equal score
    3) Total no. of matches played

    Args:
        tid: tournament id from tournament table (Optional) (Default as 1)

    Returns:
      A list of tuples, each of which contains (id, name, wins, matches):
        id: the player's unique id (assigned by the database)
        name: the player's full name (as registered)
        wins: the number of matches the player has won
        matches: the number of matches the player has played
    """
    conn = connect()
    c = conn.cursor()
    if 'tid' in kwargs:
        tid = kwargs['tid']
    else:
        tid = 1

    # Create scoreboard for specific tournament and fetch standings
    c.execute(
        "CREATE VIEW omw AS SELECT spid, SUM(score) AS omwscore FROM scoreboard WHERE spid IN (SELECT loser FROM matches WHERE winner = spid AND stid=%s) OR spid IN (SELECT winner FROM matches WHERE loser = spid AND stid=%s) GROUP BY spid",
        (tid, tid,))
    c.execute("CREATE VIEW tscoreboard AS SELECT * FROM scoreboard WHERE stid=%s;", (tid,))
    c.execute(
        "SELECT tscoreboard.spid, players.pname, tscoreboard.win, tscoreboard.played FROM tscoreboard LEFT JOIN players ON tscoreboard.spid = players.pid LEFT JOIN omw ON tscoreboard.spid = omw.spid ORDER BY tscoreboard.score DESC, omw.omwscore DESC, tscoreboard.played DESC ;")
    standings = c.fetchall()
    return standings


def reportMatch(winner, loser, **kwargs):
    """Records the outcome of a single match between two players.

    Args:
      winner:  the id number of the player who won
      loser:  the id number of the player who lost
      tid: the tournament id (Optional). Default as 1.
      draw: Boolean result to check if match is a draw (optional). Default as false.

    Features:
    Assign winner/loser according to the following at the winner column
    for winner, players.id will be inserted.

    """
    conn = connect()
    c = conn.cursor()
    if 'tid' in kwargs:
        tid = kwargs['tid']
    else:
        tid = 1

    if 'tie' in kwargs:
        tie = kwargs['tie']
    else:
        tie = False

    c.execute("INSERT INTO matches(mtid,winner,loser,tie) VALUES(%s,%s,%s,%s);", (tid, winner, loser, tie,))
    if winner == loser:
        c.execute(
            "UPDATE scoreboard SET win = win+1, played=played+1, bye=bye+1, score=score+3 where spid=%s AND stid=%s;",
            (winner, tid))
    elif tie:
        c.execute("UPDATE scoreboard SET tie = tie+1, played=played+1, score=score+1 where spid=%s AND stid=%s;",
                  (winner, tid))
        c.execute("UPDATE scoreboard SET tie = tie+1, played=played+1, score=score+1 where spid=%s AND stid=%s;",
                  (loser, tid))
    else:
        c.execute("UPDATE scoreboard SET win = win+1, played=played+1, score=score+3 where spid=%s AND stid=%s;",
                  (winner, tid))
        c.execute("UPDATE scoreboard SET lose = lose+1, played=played+1, score=score where spid=%s AND stid=%s;",
                  (loser, tid))
    conn.commit()
    conn.close()


def checkRematch(p1id, p2id, **kwargs):
    """Check if the 2 selected players have played in previous matches within the same tournament.

        Args:
          p1id:  the id number of the first player
          p2id:  the id number of the second player
          tid: the tournament id (Optional). Default as 1.

        Return:
          True: Players have played in past match within the same tournament
          False: Players have not played in past match within the same tournament
    """

    if 'tid' in kwargs:
        tid = kwargs['tid']
    else:
        tid = 1

    # To prevent rematch
    conn = connect()
    c = conn.cursor()
    c.execute(
        "SELECT winner, loser FROM matches WHERE ((winner = %s AND loser = %s) OR (winner = %s AND loser =%s)) AND mtid=%s;",
        (p1id, p2id, p2id, p1id, tid))
    pastplay = c.fetchone()
    if pastplay is not None:
        return True
    return False


def checkBye(pid, **kwargs):
    """Check if the selected player has been won with a skipped round (bye) in past matches within the tournament.

        Args:
          pid:  the id number of the player
          tid: the tournament id (Optional). Default as 1.

        Return:
          True: Player has a skipped round previously in the tournament
          False: Player has no skipped round in the tournament
          Error: More than 1 skipped round win has been granted to player. (For development fault finding)
    """
    if 'tid' in kwargs:
        tid = kwargs['tid']
    else:
        tid = 1

    # To prevent more than one bye
    conn = connect()
    c = conn.cursor()
    c.execute(
        "SELECT bye FROM scoreboard WHERE spid=%s AND stid=%s;", (pid, tid,))
    pastbye = c.fetchone()[0]
    if pastbye == 1:
        return True
    elif pastbye == 0:
        return False
    else:
        print("More than one bye win has been assigned to Player ID: %s at tournament ID: %s", (pid, tid,))


def swissPairings(**kwargs):
    """Returns a list of pairs of players for the next round of a match.
  
    The function will check if there is an odd number of players registered in the tournament and assign a bye win to one of the players with no bye history.
    It will generate a pair list with no player having to rematch with his opponent.

    Args:
        tid: the tournament id (Optional). Default as 1.

    Returns:
      A list of tuples, each of which contains (id1, name1, id2, name2)
        id1: the first player's unique id
        name1: the first player's name
        id2: the second player's unique id
        name2: the second player's name
    """
    if 'tid' in kwargs:
        tid = kwargs['tid']
    else:
        tid = 1

    scorerank = playerStandings(tid=tid)
    tot_player = countPlayers(tid=tid)
    pair_list = []
    rematchlen = len(scorerank)
    byelen = len(scorerank)

    if tot_player % 2 != 0:
        while byelen > 1:
            i = 0
            while i < byelen - 1:
                if not checkBye(scorerank.pop(i)):
                    bye = scorerank.pop(i)
                    while rematchlen > 1:
                        j = 0
                        while j < rematchlen - 1:
                            pa = scorerank.pop(0)
                            rematchlen = len(scorerank)
                            if not checkRematch(pa[0], scorerank[j][0], tid=tid):
                                pb = scorerank.pop(j)
                                pair_list.append((pa[0], pa[1], pb[0], pb[1]))
                                j = 0
                                continue
                            else:
                                j += 1
                    pair_list.append((bye[0], bye[1], bye[0], bye[1]))
                else:
                    i += 1
    else:
        while rematchlen > 1:
            j = 0
            while j < rematchlen - 1:
                pa = scorerank.pop(0)
                rematchlen = len(scorerank)
                if not checkRematch(pa[0], scorerank[j][0], tid=tid):
                    pb = scorerank.pop(j)
                    pair_list.append((pa[0], pa[1], pb[0], pb[1]))
                    j = 0
                    continue
                else:
                    j += 1

    return pair_list
